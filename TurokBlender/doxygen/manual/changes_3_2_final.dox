/** \page "Final Patch Modding Details"

<H3>Info/Changes</H3>
\verbatim
Weapons:
- OnTick was being called twice. It's been fixed to only be called once.
If your mods logic required that second tick then you can use the new optional function void OnActorTick().
These changes require that you now double the speed of the AutoShotgun, Minigun, and Shockwave barrel rotation speed.
- OnFire is now properly called when holding the fire button and you have no ammo.
These changes require you to check if the weapon has ammo in your OnFire() functions.
- new optional function void OnPreRaise(). Called right when the weapon state is set to raise.
- new weapon def keys: fov 47.5, noWalkAnim 1, noGenericBobbing 1, forceGenericBobbing 1

New main global script functions:
"void GlobalTick()"
"void GlobalPostTick()"
"void GlobalBeginLevel()"
"void GlobalPostBeginLevel()"
"void GlobalEndLevel()"

New ActorFx Property:
    $spawnfx (375, {0.0 0.0 0.0}, 0.0) // FxID, {x, y, z} position relative to actor, time to keep spawning this particle (use 0 to spawn it only once).

Custom ttf font examples:
add custom ttf font in "defs/fileLookup.txt". For each font string the left side of the Pipe(|) character is the path to the font and the right side is the font size.
The ttf font that the game uses is "fonts/zeroes_three.otf" and it has a font size of 48.
Keep in mind to access the font you must add a value of 4 to use it. so when using the Game.AddText function pass in 4 to use the $0 custom font and 5 to use $1 and so on.
This is an example of adding custom fonts:
Fonts
{
    $0 = "fonts/RobotoMono-MediumItalic.ttf|48"
    $1 = "fonts/RobotoMono-SemiBold.ttf|24.123"
}

Materials .kmat files:
Added new property "uv_scroll". It's not effected by gamespeed and only the following shaders work with it:
    world, world_purdycolors, colorOverlay, colorEmissive, worldSphereMap, worldSphereMapOverlay, trail
Usage:
    uv_scroll "1.0 0.5"
    
Console command "puke" has been readded.

Menu Sounds now using their own sounds shaders.
Time Trial Start: "sounds/shaders/tt_start.ksnd"
Menu Navigation: "sounds/shaders/menu_item_nav.ksnd"
Menu Select:"sounds/shaders/menu_item_select.ksnd"

--------------------------------------------------
ScriptObjectFx
--------------------------------------------------
Constructor:
    kFx @self;
    TurokFxTest(kFx @fx)
    {
        @self = fx;
    }

Required Functions:    
    void OnTick(void)

Optional Functions:
    void OnRemoved(void)
    void OnCollide(kCModel @pCModel)    // Called just before any of the OnImpact functions.
    bool OnImpactWall(int impactType, const kVec3 &in normal)
    bool OnImpactFloor(int impactType, const kVec3 &in normal)
    bool OnImpactCeiling(int impactType, const kVec3 &in normal)
    bool OnImpactObject(int impactType, int impactDmgType, kActor@ actor, const kVec3 &in normal)
    void OnImpactWater(void)
    void OnExpire(void)    

---------------------------
New Trail Defs:
---------------------------
EdgeSpeed now effects trails on models. (1.0 is every tick at GameSpeed 1. For Fx 4.0 is every tick at GameSpeed 1)

capEnds         0   //Integer (default = 0). 0 = None. 1 = Cap Start. 2 = Cap End. 3 = Cap Start and End.
                    // * This only works if the edges create a convex polygon and the edges (vertices) are ordered (CW or CCW)

useCapUV        1   //Bool (default = 0). Will enable the use of cap UV values that you specify in each vertex def.

fxDrawType      -10 //Integer (default = 10). Override the Fx drawType. This effects the edge matrix that multiplies the edge position. (for trails attached to Fx only).
                    //Using negative values will always use the starting trail matrix for each edge that's added. Example: -5 will set the starting matrix to the Billboard Matrix.
                    //                       10 = Default. Uses the Fx orientation matrix that changes based on the Fx drawType.
                    //                       1 = Same as Fx drawType 1 (Flat).
                    //                       2 = Same as Fx drawType 2 (Decal).
                    //                       4 = Same as Fx drawType 4 (Surface).
                    //                       5 = Same as Fx drawType 5 (Billboard matrix).
                    //                       Other values = Same as Fx other drawTypes (Sprite matrix).

segmentsU       1   //Float (default = 1.0). Multiplies the UV.x (forward/backward) value by this amount which makes it repeat more.
segmentsV       1   //Float (default = 1.0). Multiplies the UV.y (sides) value by this amount which makes it repeat more.
startScale      1   //Float (default = 1.0). Multiplies all the edges start pos
endScale        1   //Float (default = 1.0). Multiplies all the edges end pos
startAlphaScale 1   //Float (default = 1.0). Multiplies all the edges start alpha color
endAlphaScale   1   //Float (default = 1.0). Multiplies all the edges end alpha color

smoothEdge      1   //Bool (default = 0). Moves the last Edge along with the Fx position every tick. Only works for Trails attached to Fx (Trails attached to models have always added edges every tick so this option would be pointless for them).

textureType     1   //Integer (default = 0). Must set to 1-3 to use a material. The type effects how the UV.x value will be calculated.
                    //                       0 = None (Normal untextured Turok 1 trails)
                    //                       1 = Adds UV.x by the distance it moved / 200
                    //                       2 = whenever a trail segment is added UV.x goes from 0 to 1 across all the trails edges. (slowest (but not that slow so don't worry about it))
                    //                       3 = each segments UV.x switches from 0 to 1 no matter the distance travelled.
                    
material        "materials/mat_trails/surf_trail_test"
                    // UV.y (sides) value is calculated by the number of edges in the trail. The first edge will be 0 then every edge after that the UV.y is added by:
                    // UV.y += 1.0f / (NumberOfEdges - 1.0f);

------------------------------------------------------
New Trail Vertex Defs (along with: pos, color, alpha):
------------------------------------------------------
u 0.0   // Float (default 0). If exists in start vertex then will use this uv.x value for the start cap. If exists in the end vertex then will use that for the end cap. If this exists in the start vertex but not the end vertex then the start vertex u value is used for the end cap.
v 1.0   // Float (default 0). If exists in start vertex then will use this uv.y value for the start cap. If exists in the end vertex then will use that for the end cap. If this exists in the start vertex but not the end vertex then the start vertex v value is used for the end cap.

---------------------------
|materials/mat_trails.kmat|
---------------------------
Trail Material Notes:
- Only use "progs/trail" for the shader! Using another shader may appear to work but it isn't and may lead to graphical bugs or crashes.
- If you want a normal trail with alpha < 1.0 then you should use these properties: blend, nodepthmask (or set color_diffuse alpha to less than 1.0)
- If you want a trail that's opaque then don't include: blend, nodepthmask, and make sure the color_diffuse alpha is 1.0. Note* Trails are not sorted and so opaque may draw over or under blend trails.
- Should include depthtest
- The following material properties are not used: sort, alphatest, alphafunc, alphamask, fullbright, color_environment, param
- You can use the cull property if you want but not including it is generally recommended so both sides of the triangles are drawn.
- You can also use the uv_scroll property

material surf_trail_test {
    shader "progs/trail"
    blend
    depthtest
    color_diffuse "0.000000 1.000000 0.501961 0.625000"
    
    sampler "diffuse" 0 "textures/tex0001_00.png" {
        filter      linear
        wrap        mirrored
    }
}

material surf_trail_test2 {
    shader "progs/trail"
    depthtest
    color_diffuse "1.0 1.0 1.0 1.0"

    sampler "diffuse" 0 "textures/tex0169_00.png" {
        filter      linear
        wrap        repeat
    }
}

class kStr:
    kStr Substr(uint64 start, uint64 length) const; ///< Return a substring from the current string. Will return the current string if start or length indexes are out of range.
    kStr ReplaceSubstr(const kStr &in from, const kStr &in to) const; ///< Returns a new kStr that replaced all occurrences of from with to.
    bool StartsWith(const kStr &in s) const; ///< Returns true if this string starts with s
    bool EndsWith(const kStr &in s) const; ///< Returns true if this string ends with s
    const int8 opIndex(const uint64 i) const; ///< Returns the ASCII code of the character at the strings index
    int8 &opIndex(const uint64 i); ///< Get/Set the ASCII code of the character at the strings index

Game:
    void SetTextOrder(const int id, const int order);
    void SetPicOrder(const int id, const int order);
    void ClearTextInterpolation(const int id);
    void ClearPicInterpolation(const int id);    
    void OpenBindingsMenu();
    void OpenOptionsMenu(); ///< saves config file when exiting this menu
    void OpenHeadBobbingMenu();
    void OpenActionBindingsMenu();
    void OpenWeaponBindingsMenu();
    void OpenMenuBindingsMenu();
    void OpenAutomapBindingsMenu();
    void OpenLevelKeysMenu();
    void OpenHUDOptionsMenu();
    void OpenGameplayMenu();
    void OpenGraphicsMenu();
    void OpenAudioMenu();
    bool EnemiesAlwaysDropItems();  ///< Returns the gameplay menu option value
    void OverrideRespawningEnemies(const int value);  ///< Set: Game.OverrideRespawningEnemies();  Get: GameVariables.GetInt("OverrideRespawningEnemies", result);  0=none, 1=force disable, 2=force enable
    void OverrideBloom(const int value);  ///< Set: Game.OverrideRespawningEnemies();  Get: GameVariables.GetInt("OverrideRespawningEnemies", result);  0=none, 1=force disable, 2=force enable
    void PlayMusicID(const int musicID, const int fadeTimeMS = 500, const bool loop = true);
    bool MusicIsFading();
    bool IsRunningMapScript(const int scriptID);
    kStr GetMapNameFromID(const int mapID); ///< Finds the name of the map with the mapID
    const float GetMaxZDrawDistance();  ///< Returns GetExtraZFar + the max z-draw distance from the active map def.
    bool IsCheatActive(const int cheatBits); ///< EnumCheatFlags. Returns true if cheats are active
    void SetWaterReflectionAlpha(const float alpha);            ///< Default is 1.0f
    void EnableWaterReflectionViewPoint(const bool enable);
    void SetWaterReflectionViewPoint(const kVec3 &in point);
    void NextSoundVolumeScale(const float volume);  ///< The next play sound will scale the volume by this much
    void NextSoundPitchScale(const float pitch);   ///< The next play sound will scale the pitch by this much
    kDictMem @GetActorDef(const kStr &in name); ///< Returns the Actors Def by name
    kDictMem @GetActorDef(const int type)   ///< Returns the Actors Def by it's type
    void GetActorInBounds(const kVec3 &in min, const kVec3 &in max);    ///< The array of actors is stored in Game.GetActorResult
    void GetFxInBounds(const kVec3 &in min, const kVec3 &in max);   ///< The array of Fx is stored in Game.GetFxResult
    void GetSectorInBounds(const kVec3 &in min, const kVec3 &in max);   ///< The array of sectors is stored in Game.GetSectorResult
    uint GetActorResultsLength();   ///< Use after calling Game.GetActorInBounds
    uint GetFxResultsLength();  ///< Use after calling Game.GetFxInBounds
    uint GetSectorResultsLength();  ///< Use after calling Game.GetSectorInBounds
    kActor @GetActorResult(const uint index); ///< Use after calling Game.GetActorInBounds. Do not use at any other point!
    kFx @GetFxResult(const uint index); ///< Use after calling Game.GetFxInBounds. Do not use at any other point!
    int @GetSectorResult(const uint index); ///< Use after calling Game.GetSectorInBounds. Do not use at any other point!
    void NextSpawnFxSetResults(); ///< On the next call to SpawnFx or any other function that calls SpawnFx (such as SpawnProjectile and FireProjectile), all the Fx that were spawned will be stored in Game.GetFxResult. Do not make nested calls to this!
    kStr GetFxFile(const int fxID); ///< Returns the file path to the Fx by ID value as defined in defs/fileLookup.txt
    
kPlayLoop:
    const float Ticksf(void) const;
    
kRenderModel:
    void ScaleOverride(const int node, const kVec3 &in scale);
    kVec3 &PrevOffset();
	void SetRotationOffset(const int nodeIndex, const float rads, const float x, const float y, const float z, const bool clearInterpolation = false);
	void SetRotationOffset(const int nodeIndex, const kQuat&in rotation, const bool clearInterpolation = false);

kPuppet:
    void SetHeadBobScale(const float scale);
    void SetTurnBobScale(const float scale);
    void SetStrafeBobScale(const float scale);
    void SetUnderwaterBobScale(const float scale);
    void SetJumpBobScale(const float scale);
    void SetMaxLives(const int value);  ///< Max lives from gaining Lifeforces
    void SetMaxLifeforces(const int value); ///< Amount of Lifeforces needed to get a life
    const float HeadBobScale() const;
    const float TurnBobScale() const;
    const float StrafeBobScale() const;
    const float UnderwaterBobScale() const;
    const float JumpBobScale() const;
    const int GetMaxLives() const;
    const int GetMaxLifeforces() const;
    
World:
    const kStr GetSkyMaterial() const;
    void OverrideSkyMaterial(const kStr &in path); ///< Example path: "skies/skyMaterials/sky_brown"  You can clear the sky with an empty string: ""  Do not pass in invalid paths!
    void OverrideFogColor(const int r, const int g, const int b);   ///< rgb values are 0-255
    void ClearOverrideFogColor();   ///< Stops overriding and uses the sector color
    void OverrideWaterFogColor(const int r, const int g, const int b);  ///< rgb values are 0-255
    void ClearOverrideWaterFogColor();   ///< Stops overriding and uses the sector color
    const int FindClosestSectorByDistance(const kVec3&in origin);
    const float GetAreaWaterHeight(const int area) const;
    const float GetAreaFogZFar(const int area) const;
    void SetAreaFogZFar(const int area, const float zfar);
    const float GetAreaWaterZFar(const int area) const;
    void SetAreaWaterZFar(const int area, const float zfar);
    const kVec3 GetAreaFogColor(const int area) const;  ///< color values are in range 0-255
    void SetAreaFogColor(const int area, const kVec3 &in color);    ///< color values are in range 0-255
    const kVec3 GetAreaWaterColor(const int area) const;    ///< color values are in range 0-255
    void SetAreaWaterColor(const int area, const kVec3 &in color);  ///< color values are in range 0-255
    const float GetAreaSkyHeight(const int area) const;
    void SetAreaSkyHeight(const int area, const float height);
    const float GetAreaSkySpeed(const int area) const;      ///< speed scale is this value / 100. 100 is normal speed.
    void SetAreaSkySpeed(const int area, const float speed);    ///< speed scale is this value / 100. 100 is normal speed.
    const float GetAreaBlendLength(const int area) const;   ///< the speed to interpolate the fog color/start/zfar values when they change
    void SetAreaBlendLength(const int area, const float blendLength); ///< a blendLength value of 1.0 interpolates the fog color/start/zfar values at 0.066666 (1/15) per tick.
    const int GetAreaAmbience(const int area) const;
    void SetAreaAmbience(const int area, const int ambience);
    const int GetAreaMapColor(const int area) const;
    void SetAreaMapColor(const int area, const int color);
    const int GetAreaMusic(const int area) const;
    void SetAreaMusic(const int area, const int music);
    const int GetAreaCullBits(const int area) const;    ///< if any staticmeshes cullBits have any of the area cullBits set then it will draw. (default callbits is 255)
    void SetAreaCullBits(const int area, const int bits);   ///< if any staticmeshes cullBits have any of the area cullBits set then it will draw. (default callbits is 255)
    const int GetSectorDrawOrder(const int sectorIndex) const;      ///< lowest draw order (0) draws the sectors on the automap last
    void SetSectorDrawOrder(const int sectorIndex, const int drawOrder);    ///< lowest draw order (0) draws the sectors on the automap last
    void MoveSectorPlatform(const int sectorIndex, const kVec3 &in moveDelta, const uint flags = SPR_DEFAULT); ///< EnumSectorPlatformFlags. Moves bridge sectors vertices not connected to non bridge sectors by moveDelta amount affecting actors

kAI:
    int &Regenerate();  ///< get/set current number of times the enemy will regenerate value. Regenerate is set right after OnBeginLevel is called and is set to a random value from 0 to the mapActors maxRegenerations value or the actors def ai.maxRegenerations value(for non map actors).

Actor:
    const int RefCount() const;    ///< Returns the number of references there are to this actor. If actor is stale and RefCount is 0 then it will be removed after the actor ticks.
    float SoundPlayTime(const kStr &in file) ///< returns -1 if sound is not playing. Returns the amount of time in seconds the sound has been playing for. file is the "wavefile" property in the sound shader.
    bool &RemoveTrailsOnAnimChange(); ///< Will remove all model trails on this actor when animation is set/blend
    const float GetCurrentGameSpeed(void) const; ///< Gamespeed of this Actor (default 1.0f)
    void SetCurrentGameSpeed(const float speed); ///< Gamespeed of this Actor (default 1.0f)
    bool &IgnoreGameSpeed(); ///< GameSpeed used for this actor will always be 1. (Default is true for kPuppet and kPlayerWeapon. Default is False for every other actor)
    bool &IgnoreFxGameSpeed(); ///< GameSpeed used for Fx whose source is this actor will always be 1. (Default is false)
    const float GetGameSpeed() const; ///< Returns 1 if IgnoreGameSpeed is true else returns the current GameSpeed.
    kFx @DamageFx() const;  ///< The kFx that hit this actor. Will be null if no Fx hit this actor. Only use in OnPreDamage/OnDamage/OnDeath. Do not use anywhere else or it could be pointing to a random place in memory then the game will crash!
    void CheckLinkArea();   ///< If origin or radius changed since the last LinkArea then calls LinkArea else does nothing. Links the Actor to an area node so that internally the Actor can be found in quick searches (similar to a kd-tree).
    const float DecayTime(void);    ///< Value used to melt kAI when they regen.
    void SetDecayTime(const float value);   ///< Used to melt kAI when they regen. Value range should be 0 (normal) to 60 (fully melted).
    float RadiusDamageFactor(const kVec3 &in origin, const float radius) const;
    bool &UseNewExplosiveRadiusCheck(void); ///< (default False) Set to true to enable explosive damage checks from radius to actor cylinder(more accurate) instead of radius to actors center point.
    
Actor Flags:
    AF_NONSHOOTABLE - Now works. Fx won't hit actors if this flag is set.

New Actor Defs:
    removeTrailsOnAnimChange 1  ///< Will remove all model trails on this actor when animation is set/blend
    ignoreGameSpeed 1   ///< GameSpeed used for this actor will always be 1. (Default is true for kPuppet and kPlayerWeapon. Default is False for every other actor)
    ignoreFxGameSpeed 1 ///< GameSpeed used for Fx whose source is this actor will always be 1. (Default is false)

Player Flags:
    PF_NOCEILINGGLIDE = 65536 ///< disables the ceiling glide glitch

enum EnumCheatFlags
{
	GC_BIG_HEADS = 1 << 0,
	GC_TINY_ENEMY = 1 << 1,
	GC_INFINITE_AMMO = 1 << 2,
	GC_PURDY_COLORS = 1 << 3,
	GC_SPIRIT_MODE = 1 << 4,
	GC_INVINCIBILITY = 1 << 5,
	GC_FLIGHT = 1 << 6,
	GC_DISCO = 1 << 7,
	GC_INFINITE_LIVES = 1 << 8,
	GC_ALL_MAP = 1 << 9,
	GC_SHOW_ENEMIES = 1 << 10,
	GC_NOCLIP = 1 << 11,
};
        
GameVariable Special Keys:
    int "OverrideRespawningEnemies"
    int "OverrideBloom"
    float "player.headBobScale"
    float "player.turnBobScale"
    float "player.strafeBobScale"
    float "player.underwaterBobScale"
    float "player.jumpBobScale"
    int "player.maxLives"
    int "player.maxLifeforces"
    bool "NewExplosiveRadiusCheck" ///< (default False) Set to true to enable explosive damage checks from radius to actor cylinder(more accurate) instead of radius to actors center point. For all actors in the game.

Fx New Params:
    float spawnDistOffset
    int maxInstances
    int maxBulletBounces
    bool bBounceImpact = 1  ///< Does ImpactEvents on Bounce
    float bounceImpactThreshold = 0.01 ///< will continue to do bounce impacts as long as the velocity is >= to this value
    bool bOverrideMaxDrawScale = 1 ///< override the max draw scale of the fx which by default is 4096
    float maxscale = 8192   ///< The new max draw scale if bOverrideMaxDrawScale was set
    float maxscaleRandom = 2.0   ///< The new max draw scale random factor
    bool bIgnoreGameSpeed = 1   ///< GameSpeed is always 1.0 for this Fx and the attached Trails
    kStr scriptClass = "MyTurokFxClass" ///< must inherit from ScriptObjectFx
    bool bScriptOnAllInstances = 1  ///< will create a ScriptObjectFx for every instance that gets created. Else will create a ScriptObjectFx for only the first instance.
    kStr modelName = "" ///< Use for your own custom script purposes
    kStr animName = "" ///< Use for your own custom script purposes
    kStr userString = "" ///< Use for your own custom script purposes
    int userID = 1 ///< Use for your own custom script purposes

/**
 * @class kFxIterator
 * @brief The way to iterate through all Fx in the map. Example code:
 * @code{.cpp}
 *  kFxIterator it;
 *  kFx @fx;
 *  while((@fx = it.Get()) !is null)
 *  {
 *      // Do something with fx
 *  }
 * @endcode
 */
class kFxIterator
{
public:
	kFxIterator();
	kFx@ Get(); ///< Returns the next Fx in the iterator
	void Reset(); ///< Resets the iterator back to the first Fx
};

Global Functions:
    void kStrSplit(const kStr &in s, const kStr &in sep);
    kStr kStrSplitGet(const int index); ///< returns the string at index
    uint kStrSplitLength(); ///< returns the amount of strings that were split
    void kStrSplitClear(); ///< clear the list of split strings after your done. Not required to call because it gets cleared when you call kStrSplit but if you don't want those strings still hanging around you can clear them now.

kWeapon:
    bool &ClearInterpolationOffsetPosition(); ///< Set to true to clear the OffsetPosition interpolation after the weapon ticks, then it gets set back to false.
    float &PlaySpeed(); ///< Get/Set speed of weapon animations (default = 4.0f)
    float &PlaySpeedSwapIn(); ///< Get/Set speed of weapon lower animation (default = 4.0f)
    float &PlaySpeedSwapOut(); ///< Get/Set speed of weapon raise animation (default = 3.0f)
    float &FOV();   ///< Get/Set weapon FOV
    bool &NoWalkAnim(); ///< Get/Set the usage of the walk anim. Run animation will be used instead.
    bool &ForceGenericBobbing();

kFx (New Class for Fx):
    const bool IsStale() const; ///< Fx is marked as removed and is waiting to be freed from memory when it next checks if there are no more references to this fx.
	kAngle& Yaw(); ///< Not used by the Fx
	kAngle& Pitch(); ///< Not used by the Fx
	kAngle& Roll(); ///< Not used by the Fx
    kVec3 &Origin();
    kVec3 &Scale();
    kVec3 &PrevOrigin();
    void SetTarget(kActor@ actor);
    kActor @GetTarget();
    void SetSector(const uint sectorIndex);
    kVec3 &Velocity();
    kVec3 &Movement();
    kQuat &Rotation();
    int &ImpactType(); ///< EnumImpactType
    int &ImpactTypeDmg(); ///< EnumImpactType. Overrides the damage def used. if is -1 (default) then does not override ImpactType()
    bool &IgnoreSectorHeightChange();
    float &Radius();    ///< (Default 8.0) Not really used. Only for searches for the fx to define it's bounding box.
    float &Height();    ///< (Default 8.0) Not really used. Only for searches for the fx to define it's bounding box.
    float &WallRadius();
    float &Gravity();
    float &Friction();
    float &BounceDamp();
    float &FloorHeight();
    float &CeilingHeight();
    const int SectorIndex();
    const int AreaID() const;
    bool InstanceOf(const kStr &in className) const; ///< example: InstanceOf("kexFx")
    void PlaySound(const kStr &in soundPath);
    void PlaySoundWithLookupID(const int soundID);
    void StopSound();
    void StopLoopingSounds();
    const float GetWaterHeight() const;
    const bool CanSee(kActor@ actor, const uint excludeClipFlags = 0); ///< excludeClipFlags to ignore/disable (EnumClipFlags)
    bool OnGround() const;
    int GetWaterLevel() const; ///< EnumWaterLevel
    float DistanceToPoint(const kVec3 &in point) const; ///< calls DistanceToPoint(x,y,z)
    float DistanceToPoint(const float x, const float y, const float z) const; ///< Fx point is in the center
    void MoveToPosition(const float x, const float y); ///< Moves the world object to a desired position at xy coordinates. Movement will use hitscan collision for quick collision tests.
    void SetPosition(const kVec3 &in pos, const bool clearInterpolation = true); ///< best way to set an Fx position without knowing the sector, will also find/set the sector and optionally clear interpolation
    const float GetCeilingHeight() const; ///< calculates the ceiling height from the Fx sector and origin. Returns 0 if not in a sector.
    const float GetFloorHeight() const; ///< calculates the floor height from the Fx sector and origin. Returns 0 if not in a sector.
    const int GetSectorIndexAtLocation(const kVec3 &in pos, uint excludeClipFlags = 0); ///< excludeClipFlags to ignore/disable (EnumClipFlags)
    float &AirFriction();
    float &WaterFriction();
    float &Mass();
    const float GetSkyHeight() const;
    bool &ChildOfTarget(); ///< Unused. Only used for kActors.
    void LinkArea(); ///< Links the Fx to an area node so that internally the fx can be found in quick searches (similar to a kd-tree). Use with Game.GetFxInBounds. Should only call whenever you set the actors Origin() directly and then want to call Game.GetFxInBounds right after. LinkArea will be called automatically in OnTick internally so outside of that case you never need to worry about calling this.
    void CheckLinkArea(); ///< If origin or radius changed since the last LinkArea then calls LinkArea else does nothing. Links the Fx to an area node so that internally the Fx can be found in quick searches (similar to a kd-tree). Use with Game.GetFxInBounds. Should only call whenever you set the actors Origin() directly and then want to call Game.GetFxInBounds right after. CheckLinkArea will be called automatically in OnTick internally so outside of that case you never need to worry about calling this.
    void Remove(); ///< Removes the Fx and sets stale to true. Fx will only internally be removed when there are no references to this Fx.
    const int GameTicks() const;
    float RadiusDamageFactor(const kVec3 &in origin, const float radius) const;
    bool InWater();
    kScriptObjectFx @ScriptObject();
    void ClearInterpolation();
    const bool DrawDelay() const;
    const float GetCurrentGameSpeed(void) const; ///< Gamespeed of this Fx (default 1.0f)
    void SetCurrentGameSpeed(const float speed); ///< Gamespeed of this Fx (default 1.0f)
    const float GetGameSpeed() const; ///< Returns 1 if IgnoreGameSpeed is true else returns the current GameSpeed.
    const int RefCount() const; ///< Returns the number of references there are to this Fx. If this Fx is stale and RefCount is 0 then it will be removed after the Fx ticks.
    bool HasCustomRef() const;
    void AddCustomRef(); ///< Keeps the Fx from getting freed from memory.
    void ClearCustomRef(); ///< Allows the Fx to get freed from memory if it has no references. This will be called automatically when level is unloaded.
    const int BounceCount() const;
    float &RecurseLifeTime();
    bool &DidWaterImpact();
    bool &IgnoreGameSpeed(); ///< GameSpeed used for this Fx will always be 1. (Default = false)
    kActor @GetOwnerAsActor();
    kFx @GetOwnerAsFx();
    void SetOwnerAsActor(kActor@ actor);
    void SetOwnerAsFx(kFx@ fx);
    kFx @GetParentFx();
    void SetParentFx(kFx@ fx);
    kStr FxFilePath();
    kVec3 &MuzzleOffset();
    const float Distance() const; ///< Distance to the center of the View (Player or Camera) at the time the Fx spawned.
    const float Restart() const; ///< Current delay time before the Fx will start ticking
    int &Frame(); ///< The sprite frame. Make sure this value is < MaxFrames().
    const uint MaxFrames() const; ///< MaxFrames the sprite has. Frame should be < this value.
    float &DrawScale(); ///< Current scale of the sprite
    float &DrawScaleDest(); ///< When the Fx is updating its scale OnTick, the current draw scale will increase to this value in different ways depending if bScaleLerp is true in the fx file.
    float &MaxDrawScale(); ///< The highest value the DrawScale() can become when the Fx is updating its scale OnTick.
    float &RotationOffset(); ///< Current Rotation Offset around the Y Axis. kQuat(RotationOffset(), 0.0f, 1.0f, 0.0f);
    float &RotationSpeed(); ///< Adds this value * (0.25 * GameSpeed) to RotationOffset() when updating rotation OnTick. This value is set on spawn.
    kVec3 &VelocityOffset(); ///< When Fx spawns this is set to the starting velocity of the Fx. And adds to velocity if bAddOffset is true. Has no other use.
    void SetColor1(float r, float g, float b, float a); ///< Values range from 0.0 to 1.0. Color and alpha of sprite.
    void SetColor2(float r, float g, float b, float a); ///< Values range from 0.0 to 1.0. Environment color of the sprite (used in shaders to blend color1 and color2 together). Alpha is always set to the same as Color1.
    void GetColor1(float &out r, float &out g, float &out b, float &out a); ///< Get the color values
    void GetColor2(float &out r, float &out g, float &out b, float &out a); ///< Get the color values
    const bool SwapBloodColor() const;  ///< Is true if fx has bBlood set to true and games blood menu option is set to Green(1). When RandomizeColors() is called which is done automatically when the Fx spawns.
    float &Speed(); ///< Initial forward moving speed, st on spawn from forwardSpeed and forwardSpeedRandom in the fx file.
    float &MovingForce(); ///< initial veolcity.Length() value. if bBullet is true then while updating movement OnTick, if the velocity.length() of the fx is below MovingForce() * 0.65f then removes the Fx.
    float &MuzzleLifeTime();
    const int Instances() const; ///< Same as the instances value in the fx file.
    float &FrameTime(); ///< The current time left before it tries going to the next frame in the sprite.
    int &BulletBounces();
    const int FxIndex() const;  ///< The index in the fx file array
    const int InstanceIndex() const;
    bool &DoUpdateTickEvents(); ///< If set to false the Fx will not call Tick or WaterTick events.
    bool &DoUpdateSpriteAnimation(); ///< If set to false the Fx will not update sprite frame
    bool &DoUpdateRotation(); ///< If set to false the Fx will not update rotation offset
    bool &DoUpdateScaling(); ///< If set to false the Fx will not update draw scale
    bool &DoUpdateFading(); ///< If set to false the Fx will not update color1 and color2 alpha value
    bool &DoUpdateMovement(); ///< If set to false the Fx will not move
    bool &DoUpdateExpireCheck(); ///< If set to false the Fx will not expire and get removed when lifetime is over
    bool &OnCollideForceSetOriginToLast(); ///< If set to true the Fx will set it's origin and sector to what it was before OnCollide was called.
    bool &OnCollideForceNoSetOriginToLast(); ///< If set to true the Fx will never set it's origin and sector to what it was before OnCollide was called.
    void SpawnImpactFx(const int impactType, const kVec3 &in normal, const bool bUseEvent = true, const bool bBlood = true);
    void SpawnWaterImpactFx();
    void RandomizeColors();
    const int FxID() const;
    bool InfoFadeout(void) const;
    bool InfoStopAnimOnImpact() const;
    bool InfoOffsetFromFloor() const;
    bool InfoTextureWrapMirrorWidth() const;
    bool InfoTextureWrapMirrorHeight() const;
    bool InfoLensFlares() const;
    bool InfoBlood() const;
    bool InfoAddOffset() const;
    bool InfoDepthBuffer() const;
    bool InfoScaleLerp() const;
    bool InfoActorInstance() const;
    bool InfoNoDirection() const;
    bool InfoFlash() const;
    bool InfoProjectile() const;
    bool InfoDestroyOnWaterSurface() const;
    bool InfoStickOnTarget() const;
    bool InfoBullet() const;
    bool InfoWeaponView() const;
    bool InfoFullScreen() const;
    bool InfoDecalOffset() const;
    bool InfoNoSpawnNear() const;
    bool InfoNoSpawnFar() const;
    bool InfoOverrideMaxDrawScale() const;
    bool InfoIgnoreGameSpeed() const;
    bool InfoAttachSource() const;
    bool InfoDrawOnBottom() const;
    bool InfoSparkle() const;
    bool InfoCrossFade() const;
    bool InfoImpactEffect() const;
    bool InfoRestrictAim() const;
    bool InfoNoWallSpawn() const;
    bool InfoNoGroundSpawn() const;
    bool InfoNoHitSource() const;
    bool InfoPerPolyCollision() const;
    bool InfoMuzzleEffect() const;
    bool InfoDrawDelay() const;
    bool InfoBounceImpact() const;
    float InfoBounceImpactThreshold() const;
    float InfoNoSpawnNearFarDist() const;
    float InfoMass() const;
    float InfoTranslationGlobalRandomScale() const;
    kVec3 InfoTranslation() const;
    float InfoGravity() const;
    float InfoFriction() const;
    float InfoAirFriction() const;
    float InfoWaterFriction() const;
    float InfoAnimFriction() const;
    kVec3 InfoMuzzleOffset() const;
    float InfoScale() const;
    float InfoScaleDest() const;
    float InfoMaxscale() const;
    float InfoForward() const;
    kVec3 InfoOffset() const;
    float InfoRotationOffset() const;
    float InfoRotationSpeed() const;
    float InfoRotationPivotX() const;
    float InfoRotationPivotY() const;
    int InfoLifetime() const;
    int InfoRecurseLifetime() const;
    float InfoRestart() const;
    int InfoAnimspeed() const;
    int InfoOnCollideActor() const;
    int InfoOnCollideWall() const;
    int InfoOnCollideFloor() const;
    int InfoDrawType() const;
    int InfoAnimType() const;
    int InfoVisibilityType() const;
    kVec3 InfoWhiteColor() const;
    kVec3 InfoBlackColor() const;
    float InfoHueRandom() const;
    float InfoSaturationRandom() const;
    float InfoBrightnessRandom() const;
    int InfoFadeinTime() const;
    int InfoFadeoutTime() const;
    int InfoMaxBulletBounces() const;
    int InfoMaxInstances() const;
    float InfoSpawnDistOffset() const;
    kStr InfoModelName() const; ///< Custom use
    kStr InfoAnimName() const; ///< Custom use
    kStr InfoUserString() const; ///< Custom use
    int InfoUserID() const; ///< Custom use
    
enum EnumSectorPlatformFlags
{
    SPF_FLOORVERTS          = (1 << 0),   ///< Changes sectors verts origin
    SPF_CEILINGVERTS        = (1 << 1),   ///< Changes sectors verts heights
    SPF_SAMEAREA            = (1 << 2),   ///< Effects sectors only with the same area as the starting sector
    SPF_MOVEPLAYERINAIR     = (1 << 3),   ///< Player moves with the sectors even in the air
    SPF_USEMOVETOFORPLAYER  = (1 << 4),   ///< Uses the MoveToPosition function to set the Players origin. else sets origin.
    SPF_USEMOVETOFORAI      = (1 << 5),   ///< Uses the MoveToPosition function to set the AI origin. else sets origin.
    SPF_USEMOVETOFOROTHER   = (1 << 6),   ///< Uses the MoveToPosition function to set other actors origin. else sets origin.
    SPF_MOVEPLAYER          = (1 << 7),   ///< Moves player
    SPF_MOVEAI              = (1 << 8),   ///< Moves AI
    SPF_MOVEOTHERACTORS     = (1 << 9),   ///< Moves other actors on the sectors that are not the player or AI.

    SPF_DEFAULT = SPF_FLOORVERTS|SPF_CEILINGVERTS|SPF_MOVEPLAYERINAIR|SPF_USEMOVETOFORPLAYER|SPF_MOVEPLAYER|SPF_MOVEAI|SPF_MOVEOTHERACTORS
};

\endverbatim

*/
